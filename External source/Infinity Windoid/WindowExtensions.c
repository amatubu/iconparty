/*	File:		WindowExtensions.c		Contains:	Routines to support floating windows		Written by:	Dean Yu	Updated by: Dave Johnson		Copyright:	© 1993-1995 Apple Computer, Inc.		Change History (most recent first):----------------------------------	6/95 Dave Johnson (dkj)Issue 23		• Extensive rewrite, largely to remove any dependencies on WindowRecords. It now 			compiles fine with STRICT_WINDOWS defined. There was a price: I now use the refCon			of the window to store the extensions, so it's not directly available to the app,			but I also put a userRefCon field in the structure and wrote the routines			SetExtWRefCon and GetExtWRefCon as direct replacements for Get/SetWRefCon. See the 			code for details. Also, see the file "Fixed Bug List" for some details about what			and how and why things were changed.		Some Highlights:			- New data structure, WindowRefExtensions, replacing the old WindowRecordExtensions				structure. A handle to this structure is stored in the window's refcon. If you				want to use the refCon for your own purposes, use the supplied routines				SetExtWRefCon and GetExtWRefCon instead of the normal toolbox routines.			- Uses Apple's new macro accessors for window fields (Universal Interfaces 2.0) where 				possible.			- Always allows system to allocate storage for windows (new recommendation from Apple).			- Changed gadget variant codes for floaters to match those used for the 7.5 floating				WDEF (and Infinity WDEF 3.0).			- Restructuring and factoring of common code in NewWindowReference and				GetNewWindowReference.			- Rewrite of ValidateWindowList to avoid using the window list directly.			- WindowIsModal changed to detect "manually created" modal windows.4/95 Dave Johnson (dkj)Issue 22		• Since WindowRef is now declared in the Universal Headers, removed its definition			and made necessary code changes (a few casts from WindowRef to			WindowRecordExtensions, etc.).		• Removed GetWindowList() and SetWindowList() routines, replacing with			LMGet..., LMSet...		• Fixed a bug where windows would be highlighted if created while the app was in the			background, for instance by responding to Apple Events. This was not pretty:			Unfortunately this library was written assuming that windows are only created in			the foreground. Here's what I did: I identified every place that window highlighting			might change or windows might be shown, and inserted a check to make sure the app			is in the foreground. If anyone out there can think of a better way to handle this,			I'd love to hear about it at dkj@apple.com.		• Fixed other little problems and simplified the sample a bit where possible.8/26/94	Dave Johnson (dkj)Issue 20	• replace #include SysEqu.h with #include LowMem.h			• Changed GetWindowList and SetWindowList to use LMGetWindowList			  and LMSetWindowList.			• Reworked Floater Sample, pulling global definitions out of the 			  header files, moving it to Metrowerks, using precompiled headers, etc.3/14/94		• Added ValidateWindowList. This routine is a safegaurd to make sure that nothingIssue 18	  else reorders windows behind the application’s back, causing document windows			  to appear in front of floating windows.			• Added some empty defines to WindowExtensions.h so people without Universal			  header files can compile it.			• Somewhere between now and September, I had rolled in some fixes Troy			  Gaul made to the code, but I don’t remember when or what.			  9/21/93		• Added more comments. Descbribed use of USES68KINLINES and USESROUTINEDESCRIPTORSIssue 16 (?)  flags in the makefile.			• Bumped demo version number to 1.0d2 because I forgot to change it for the			  last couple of changes.			  9/1/93		• Change SuspendFloatingWindows() so that it starts looking for floating			  windows from the beginning of the window list (GetWindowList()) instead			  of from the first visible window (FrontWindow()).			• Fixed write to NIL bug in HideReferencedWindow() when there are no			  floating windows, and the front document window is hidden.			• Fixed GetNewWindowReference so that it really gets the 'WDEF' resource ID			  for the window it’s creating.			  8/13/93		• Fixed bug in NewWindowReferenced that prevented document windows from being			  created in front when there are no floating windows.			• Added WindowIsModal() routine which determines if a window is modal or not.			  Changed ShowReferencedWindow to use this routine.			• Updated use of UniversalProcPtrs to match PowerPC development.6/93		• First version.  Released on Bookmark CD accompanying develop issue 15.*/#ifdef __APPLE_CC__#include	<Carbon/Carbon.h>#else#include <Types.h>#include <Events.h>#include <Gestalt.h>#include <Memory.h>#include <Menus.h>#include <Processes.h>#include <Resources.h>#include <LowMem.h>		// dkj replaced SysEqu.h#include <ToolUtils.h>#include <Windows.h>#include <Errors.h>#endif#include "WindowExtensions.h"// Internal routine prototypesstatic void 	MyActivateWindow(WindowRef theWindow);static void 	MyDeactivateWindow(WindowRef theWindow);static void 	HighlightAndActivateWindow(WindowRef theWindow, Boolean activate);#if !TARGET_API_MAC_CARBONstatic Boolean	GetWasVisible(WindowRef windowReference);#endifstatic void		SetWasVisible(WindowRef windowReference, Boolean wasVisible);// dkj added thesestatic OSErr	AttributesToWindowInfo(MyWindowAttributes attributes,						short *procID, Boolean *hasGoAway, MyWindowAttributes *titleBarType);static OSErr	CheckWindowOrdering(Boolean isModal, Boolean isFloater, WindowRef *behind);static OSErr	GetWINDStats(short windID, Boolean *isModal, Boolean *isFloater, Boolean *isVisible);static void		BringFloatersToFront(WindowRef thisWindow);//// NewWindowReference////	Create a new window, and return a reference to it.//	pascal OSErr NewWindowReference(WindowRef *windowReference, const Rect *boundsRect, ConstStr255Param title, Boolean visible, MyWindowAttributes attributes, WindowRef behind, long refCon, ActivateHandlerUPP activateHandlerProc){	WindowRef			newWindowReference;	WindowRefExtensions	**newExtensionsH;	long				gestaltResult;	OSErr				gestaltError;	OSErr				result;	short				procID;	Boolean				hasGoAway = false, isModal;	MyWindowAttributes	titleBarType;		// Assume failure	*windowReference = 0; 	// Convert attributes to a procID and a close box Boolean 	result = AttributesToWindowInfo(attributes, &procID, &hasGoAway, &titleBarType); 	if(result != noErr)	// Might want to special case kUndefinedTitleBarTypeError 		return result; 	 	// see if it's modal: no titlebar or hasModalBorder  	isModal = (titleBarType == 0) || (attributes & kHasModalBorderMask); 	 	// Check for invalid ordering 	result = CheckWindowOrdering(isModal, titleBarType == kHasPaletteTitlebarMask, &behind); 	if(result != noErr) 		return result;  	// Allocate space for our extensions	newExtensionsH = (WindowRefExtensions **)NewHandle(sizeof(WindowRefExtensions));		if ((result = MemError()) == noErr) {	// Call the real Window Manager routine to create the window:	// If Color Quickdraw is available, always create a color window.  If Color Quickdraw	// is not around, or Gestalt spewed, create a classic window.			gestaltError = Gestalt(gestaltQuickdrawVersion, &gestaltResult);		if ((gestaltError != noErr) || (gestaltResult == gestaltOriginalQD))			newWindowReference = NewWindow(nil, boundsRect, title, false, procID,  behind,				hasGoAway, (long)newExtensionsH);		else			newWindowReference = NewCWindow(nil, boundsRect, title, false, procID,  behind,				hasGoAway, (long)newExtensionsH);				// If a window was created, set its refcon and activate event handler proc and show		// it if the caller wanted a visible window.		if(newWindowReference != nil)		{			result = noErr;			*windowReference = newWindowReference;		// Return a reference to the window			SetExtWRefCon(newWindowReference, refCon); // stash user's refCon			SetActivateHandlerProc(newWindowReference, activateHandlerProc);						if (titleBarType == kHasPaletteTitlebarMask)	// Set the windowKind for floating windows				SetWindowKind(newWindowReference, kApplicationFloaterKind);							if (visible)								// Show the window, maybe			{				// if a floater and we're not the front process,				// this routine will just mark it to be shown when we resume				ShowReferencedWindow(newWindowReference);			}		}		else // window not created, clean up		{			DisposeHandle((Handle)newExtensionsH);			result = kWindowNotCreatedError;		}	}			return result;}//// GetNewWindowReference////	Create a window based on information in the specified resource.//pascal OSErr GetNewWindowReference(WindowRef *windowReference, short windResourceID, 						WindowRef behind, ActivateHandlerUPP activateHandlerProc){	WindowRef	newWindowReference;	WindowRefExtensions	**newExtensionsH;	Boolean		isModal, isFloater, isVisible;	long		gestaltResult;	OSErr		gestaltError;	OSErr		result;		WindowPtr	window;		// Assume failure	*windowReference = 0;		// Figure out if this is a floating window, based upon the resource ID of the 'WDEF',	// specified in the 'WIND', and see if it's specified visible	result = GetWINDStats(windResourceID, &isModal, &isFloater, &isVisible);		// return if there are errors 	if(result != noErr) 		return result;   	// Check for invalid ordering 	result = CheckWindowOrdering(isModal, isFloater, &behind);		// return if there are errors 	if(result != noErr) 		return result;  	// Allocate space for our extensions	newExtensionsH = (WindowRefExtensions **)NewHandle(sizeof(WindowRefExtensions));		if ((result = MemError()) == noErr)	{		// Create a window based on the specified 'WIND' resource.  If Color Quickdraw		// is around, create a color window, otherwise, make a black and white one.		gestaltError = Gestalt(gestaltQuickdrawVersion, &gestaltResult);		if ((gestaltError != noErr) || (gestaltResult == gestaltOriginalQD))			newWindowReference = GetNewWindow(windResourceID, nil, behind);		else			newWindowReference = GetNewCWindow(windResourceID, nil, behind);				// If a window was created, set its refcon and activate event handler proc		if (newWindowReference != nil)		{			long	userRefCon;						*windowReference = newWindowReference;		// Return a reference to the window			// preserve existing refCon			userRefCon = GetWRefCon(newWindowReference);			SetWRefCon(newWindowReference, (long)newExtensionsH);			SetExtWRefCon(newWindowReference, userRefCon);						SetActivateHandlerProc(newWindowReference, activateHandlerProc);						// Set the windowKind for floating windows, and make sure floaters are			// hidden if app is in the background.			if (isFloater)			{				SetWindowKind(newWindowReference, kApplicationFloaterKind);				if (isVisible)		// Hide the floater, maybe				{					// if we're not the front process, hide it and mark it to be shown when we resume					if(!IsFrontProcess())					{						// This is kinda gross, because floaters, if specified visible in						// the WIND, will be shown briefly, then hidden. Oh, well. The lesson						// is to always specify invisible in floater WIND resources.						ShowHide(newWindowReference, false);						SetWasVisible(newWindowReference, true);					}					}			}			else			{				SelectReferencedWindow(newWindowReference);				MyActivateWindow(newWindowReference);				window=GetNextWindow(newWindowReference);				MyDeactivateWindow(window);			}		}		else // window not created, clean up		{			DisposeHandle((Handle)newExtensionsH);			result = kWindowNotCreatedError;		}	}	return result;}//// DisposeWindowReference////	Free the memory used by a window.  If it is visible, hide it first so//	that the proper activate and deactivate events are sent.//pascal void DisposeWindowReference(WindowRef windowReference){	WindowRefExtensions		**extH;	if (IsWindowVisible(windowReference))		HideReferencedWindow(windowReference);	extH = (WindowRefExtensions **)GetWRefCon(windowReference);	if(extH != nil)		DisposeHandle((Handle)extH);	DisposeWindow(windowReference);}//// SelectReferencedWindow//// Select the specified window, and bring it to the front if its portion// of the window list.//#if !TARGET_API_MAC_CARBONpascal void SelectReferencedWindow(WindowRef windowToSelect){	WindowRef			currentFrontWindow;	WindowRef			lastFloatingWindow;	Boolean				isFloatingWindow;	Boolean				isFrontProcess;		// Find out if we're in front	isFrontProcess = IsFrontProcess();		// Set up some variables 	if (GetWindowKind(windowToSelect) == kApplicationFloaterKind) {		isFloatingWindow = true;		currentFrontWindow = FrontWindow();	}	else {		isFloatingWindow = false;		currentFrontWindow = MyFrontNonFloatingWindow();		lastFloatingWindow = LastFloatingWindow();	}	// Be fast (and lazy) and do nothing if we don’t have to.	if (currentFrontWindow != windowToSelect) {		// Selecting floating windows are easy, since they’re always active		if (isFloatingWindow)			BringToFront(windowToSelect);		else // a doc window		{			// deactivate current front window			if(isFrontProcess)				MyDeactivateWindow(currentFrontWindow);							// If there are no floating windows, we can use BringToFront			if (lastFloatingWindow == nil)				BringToFront(windowToSelect);			else // otherwise, use SendBehind to put it behind the last floater			{				// Bring it behind the last floating window and activate it.				// Note that Inside Mac 1 states that you need to call PaintOne() and CalcVis() on a				// window if you are using SendBehind() to bring it closer to the front.  With System 7,				// this is no longer necessary.				SendBehind(windowToSelect,  lastFloatingWindow);			}						// Activate the new front window			if(isFrontProcess)				MyActivateWindow(windowToSelect);		}	}}//// ShowReferencedWindow////	Show the specified window.  If the window is the frontmost document window,//	unhighlight the window behind it, deactivate it, and activate this one. If //	the window is modal, make sure it's in front.//pascal void ShowReferencedWindow(WindowRef windowToShow){	WindowRef			windowBehind;	ActivateHandlerUPP	activateHandlerProc;	short				windowClass;	Boolean				needsActivate;	Boolean				highlightState;	Boolean				isFrontProcess;	Boolean				modalUp;	Boolean				showingModal;		// If it's already visible, do nothing	if (IsWindowVisible(windowToShow) != false)		return;			// Find out if we're the front process	isFrontProcess = IsFrontProcess();		// Get the window kind	windowClass = GetWindowKind(windowToShow);		// Check for modal windows	modalUp = WindowIsModal(FrontWindow());	showingModal = WindowIsModal(windowToShow);		if(showingModal)	{		// if we're showing a modal window, make sure it's in front, regardless of 		// whether we're the front process		BringToFront(windowToShow);	}	// Play it safe and make sure the windows in the window list	// are all in the right place.	ValidateWindowList();		// If we're not the front process and the window is a floater, don't show it	// but mark it to be shown on resume.	if(!isFrontProcess && windowClass == kApplicationFloaterKind)	{		SetWasVisible(windowToShow, true);		return;	}		// OK, decipher what to do: There are two variables,	// the highlightStatus of the window and whether it wants an activate event.	// Of course, they're always the same, but, um, well, there are still two of them.	// Note that we don't actually do anything yet, just figure out what should be done.		if(isFrontProcess)	{		if(showingModal)		{			// always activate and highlite modal windows			highlightState = true;			needsActivate = true;		}		else if(modalUp) // There's a modal window up already and this one isn't modal		{			// no highlight and no activate, whatever the window type			highlightState = false;			needsActivate = false;		}		else // no modal up, and this one isn't modal, need to check the type to decide what to do		{			if(windowClass == kApplicationFloaterKind)			{				// new floaters are always highlighted and activated				highlightState = true;				needsActivate = true;			}			else // not a floater			{				WindowRef	frontNonFloater = MyFrontNonFloatingWindow();								// If this is the only non floating window, highlight and activate				if(frontNonFloater == nil)				{					highlightState = true;					needsActivate = true;				}				else // There are other document windows.				{					// assume that we're behind the front one					highlightState = false;					needsActivate = false;										// Now walk through the window list behind us to see if					// we're actually in front of the frontmost document window. If so,					// unhighlight the front one and mark the newly shown one					// for a highlight and activate					windowBehind = GetNextWindow(windowToShow);					while(windowBehind != nil)					{						if (windowBehind == frontNonFloater)						{							// Yep, we're coming up in front of the front doc window. Deactivate							//  it right now and set up highlight and activate for the new one							MyDeactivateWindow(frontNonFloater);							highlightState = true;							needsActivate = true;							break;						}						windowBehind = GetNextVisibleWindow(windowBehind);					}				}			}		}	}	else // not front process, don't activate no matter what	{		// Note that the floater case was handled above, so this is a non-floater fer sure.		highlightState = false;		needsActivate = false;	}		// Whew! Finally we know what to do, now set highlighting appropriately before showing window	HiliteWindow(windowToShow, highlightState);		// Show the window	ShowHide(windowToShow, true);		// If this is the new frontmost document window or a floating window, send it an activate event	// needsActivate can only be true if isFrontProcess is true	if (needsActivate) {		activateHandlerProc = GetActivateHandlerProc(windowToShow);		if (activateHandlerProc != nil)			CallActivateHandlerProc(activateHandlerProc, windowToShow, kActivateWindow);	}}//// HideReferencedWindow////	Hide the specified window.  If it is frontmost, move it behind the window immediately//	behind it, like HideWindow does.//pascal void HideReferencedWindow(WindowRef windowToHide){	WindowRef			frontFloater;	WindowRef			frontNonFloater;	WindowRef			windowBehind;		// Don’t do anything if the window is already invisible.		if (IsWindowVisible(windowToHide) == false)		return;		// Get the first visible floating window, if any.		frontFloater = FrontWindow();	if (GetWindowKind(frontFloater) != kApplicationFloaterKind)		frontFloater = nil;			// Get the first visible document window, if any.		frontNonFloater = MyFrontNonFloatingWindow();		// Hide the window.		ShowHide(windowToHide, false);		// If the frontmost floating window is being hidden, move it behind the floating window	// behind it, if there is one.	if (windowToHide == frontFloater)	{		windowBehind = GetNextVisibleWindow(windowToHide);				// Only do the rearrangement if there’s another floating window.		if ((windowBehind != nil) && (GetWindowKind(windowBehind) == kApplicationFloaterKind))		{						/* It used to be this...						SetNextWindow(windowToHide, GetNextWindow(windowBehind));			SetNextWindow(windowBehind, windowToHide);			LMSetWindowList(windowBehind);						...but this seems simpler, and doesn't use the window list directly  */			BringToFront(windowBehind);		}	}	// If the frontmost document window was hidden, send it behind the document window	// behind it, if there is one.	else if (windowToHide == frontNonFloater)	{		windowBehind = GetNextVisibleWindow(windowToHide);				if (windowBehind != nil)		{			/* Used to be this:						SetNextWindow(windowToHide, GetNextWindow(windowBehind));			SetNextWindow(windowBehind, windowToHide);							// Set the next link of the last floating window to point to the previously second			// to front document window. If there was no floating window, change the beginning			// of the window list.			lastFloater = LastFloatingWindow();			if (lastFloater != nil)				SetNextWindow(lastFloater, windowBehind);			else				LMSetWindowList(windowBehind);			 */							SendBehind(windowToHide, windowBehind);						// The windowBehind it is now the front document window.  Highlight it and send it			// an activate event.			if (IsFrontProcess())				MyActivateWindow(windowBehind);		}	}}pascal void DragReferencedWindow(WindowRef windowToDrag, Point startPoint, const Rect *draggingBounds){	Rect		dragRect;	KeyMap		keyMap;	GrafPtr		savePort;	GrafPtr		windowManagerPort;	RgnHandle	dragRegion;	RgnHandle	windowContentRegion;	long		dragResult;	short		topLimit;	short		newHorizontalWindowPosition;	short		newVerticalWindowPosition;	short		horizontalOffset;	short		verticalOffset;	Boolean		commandKeyDown = false;		if (WaitMouseUp()) {		// Adjust the top of the dragging rectangle so that it’s below the menu bar			topLimit = GetMBarHeight() + 4;		dragRect = *draggingBounds;		if (dragRect.top < topLimit)			dragRect.top = topLimit;		// Set up the Window Manager port.			GetPort(&savePort);		GetWMgrPort(&windowManagerPort);		SetPort(windowManagerPort);		SetClip(GetGrayRgn());			// Check to see if the command key is down.  If it is, don’t bring the window to the	// front after the move.  Trying to do Pascal stuff in C is so much fun.  GetKeys()	// is a total pain to try to use properly from C, so I’m going to hard code where the	// command key is in the KeyMap array.			GetKeys(keyMap);		if (keyMap[1] & 0x8000)			commandKeyDown = true;			if ((commandKeyDown == true) ||			(GetWindowKind(windowToDrag) != kApplicationFloaterKind)) {						if (commandKeyDown == false)		// If there are floating windows, clip the dragging outline to draw behind the floaters.					ClipAbove(MyFrontNonFloatingWindow());			else				// If the command key was down, clip the outline to draw behind any windows above	// the window being dragged.					ClipAbove(windowToDrag);		}				// Create a region to drag			dragRegion = NewRgn();		GetWindowStructureRgn(windowToDrag, dragRegion);			// Drag the window around			dragResult = DragGrayRgn(dragRegion, startPoint, &dragRect, &dragRect, noConstraint, nil);		// Restore the port for coordinate conversion.			SetPort(savePort);		if (dragResult != 0) {			horizontalOffset = dragResult & 0xFFFF;			verticalOffset = dragResult >> 16;		// Only move it if it stayed inside the dragging box.				if (verticalOffset != -32768) {				windowContentRegion = NewRgn();				GetWindowContentRgn(windowToDrag, windowContentRegion);				newHorizontalWindowPosition = (**windowContentRegion).rgnBBox.left + horizontalOffset;				newVerticalWindowPosition = (**windowContentRegion).rgnBBox.top + verticalOffset;								MoveWindow( windowToDrag, newHorizontalWindowPosition, newVerticalWindowPosition, false);				DisposeRgn(windowContentRegion);			}		}		// Bring the window forward if the command key wasn’t down			if (commandKeyDown == false)			SelectReferencedWindow(windowToDrag);		// Get rid of the dragging region			DisposeRgn(dragRegion);	}}#endif#if !TARGET_API_MAC_CARBON//// MyFrontNonFloatingWindow////	Return the first visible window that is not a floating window.//pascal WindowRef MyFrontNonFloatingWindow(void){	WindowRef	theWindow;		if (gIsDialog)		return gFrontWindow;		// Get the first visible window in the window list.		theWindow = FrontWindow();		// Keep searching until a visible window whose windowKind is not	// kApplicationFloaterKind is found, or the end of the window list is reached.		while ((theWindow != nil) && (GetWindowKind(theWindow) == kApplicationFloaterKind)) {		do {			theWindow = GetNextWindow(theWindow);		} while ((theWindow != nil) && (IsWindowVisible(theWindow) == false));	}	return theWindow;}//// LastFloatingWindow////	Return the last floating window, whether it is visible or not, or nil if there are//	no floating windows.//#endifpascal WindowRef LastFloatingWindow(void){	WindowRef	theWindow;	WindowRef	lastFloatingWindow;		#if TARGET_API_MAC_CARBON	theWindow = GetWindowList();	#else	theWindow = LMGetWindowList();	#endif	lastFloatingWindow = nil;		// We have to search the entire window list because we don’t know what the windowKind	// of other windows in the list might be, and we have to account for the fact that a modal	// dialog might be up.		while (theWindow != nil) {		if (GetWindowKind(theWindow) == kApplicationFloaterKind)			lastFloatingWindow = theWindow;		theWindow = GetNextWindow(theWindow);	}		return lastFloatingWindow;}//// WindowIsModal////	Determines if a window is modal based upon the value of its windowKind and window variant.//pascal Boolean WindowIsModal(WindowRef windowReference){	short	windowVariant;	short	windowKind;		windowVariant = GetWVariant( windowReference);	windowKind = GetWindowKind(windowReference);	// if the window is NOT a floater, and is either dialogKind or has a modal variant,	// then return true. Otherwise, return false.	if(windowKind != kApplicationFloaterKind &&		(windowKind == dialogKind ||			(	windowVariant == dBoxProc		||				windowVariant == plainDBox		||				windowVariant == altDBoxProc	||				windowVariant == movableDBoxProc	) ) )		return true;	else		return false;}#if !TARGET_API_MAC_CARBON//// DeactivateFloatersAndFirstDocumentWindow////	Send deactivate events to all visible floating windows and the active document//	window.  This routine is called before a modal dialog is presented.//pascal void DeactivateFloatersAndFirstDocumentWindow(void){	WindowRef			firstWindow;	WindowRef			secondDocumentWindow;	WindowRef			currentWindow;		// First, make sure the window ordering hasn’t been changed behind our back	ValidateWindowList();		// Start from the frontmost window on the screen, and keep going until	// we’ve reached the second document window.		firstWindow = FrontWindow();	secondDocumentWindow = gFrontWindow = MyFrontNonFloatingWindow();	if (secondDocumentWindow != nil)		secondDocumentWindow = GetNextWindow(secondDocumentWindow);			currentWindow = firstWindow;	while (currentWindow != secondDocumentWindow) {		if (IsWindowVisible(currentWindow))			MyDeactivateWindow(currentWindow);		currentWindow = GetNextWindow(currentWindow);	}		gIsDialog=true;}//// ActivateFloatersAndFirstDocumentWindow////	ActivateFloatersAndFirstDocumentWindow should be called after a modal dialog//	is dismissed.  If the application is in the background when this routine is//	called (like when a moveable modal progress dialog was up and then disappears)//	this routine calls SuspendFloatingWindows to hide any visible floating windows//	instead.//pascal void ActivateFloatersAndFirstDocumentWindow(void){	WindowRef			firstWindow;	WindowRef			secondDocumentWindow;	WindowRef			currentWindow;	Boolean				isFrontProcess;		// Sanity check: if an app "nests" modal dialogs, and calls	// ActivateFloatersAndFirstDocumentWindow every time a dialog is dismissed	// then this could be called inappropriately. Assume that if a modal window	// is up, caller didn't really mean it :-)	if(WindowIsModal(FrontWindow()))		return;		// See if the this process is in the background.  If it is, then the floating	// windows should be hidden instead of reactivated, so SuspendFloatingWindows()	// is called instead.	isFrontProcess = IsFrontProcess();	if (isFrontProcess == false)		SuspendFloatingWindows();	else {		firstWindow = FrontWindow();		secondDocumentWindow = MyFrontNonFloatingWindow();		if (secondDocumentWindow != nil)			secondDocumentWindow = GetNextWindow(secondDocumentWindow);				currentWindow = firstWindow;		while (currentWindow != secondDocumentWindow) {			if (IsWindowVisible(currentWindow))				MyActivateWindow(currentWindow);			currentWindow = GetNextWindow(currentWindow);		}	}		gIsDialog=false;	gFrontWindow=nil;}#endif//// SuspendFloatingWindows////	Hide any visible floating windows, and deactivate the frontmost document window.//	This routine should be called when an application recieves a suspend event.//#if !TARGET_API_MAC_CARBONpascal void SuspendFloatingWindows(void){	WindowRef	currentWindow;	Boolean		windowIsVisible;		#if TARGET_API_MAC_CARBON	currentWindow = GetWindowList();	#else	currentWindow = LMGetWindowList();	#endif		// used to return here if there are no floaters, but that meant that 	// the front doc window didn't get deactivated if there were no floaters.	// Now we return only if the first visible window is modal, assuming that the floaters	// and doc window are already deactivated.	if(WindowIsModal(FrontWindow()))		return;			while ((currentWindow != nil) && (GetWindowKind(currentWindow) == kApplicationFloaterKind))	{		windowIsVisible = IsWindowVisible(currentWindow);		SetWasVisible(currentWindow, windowIsVisible);		if (windowIsVisible)			ShowHide(currentWindow, false);		currentWindow = GetNextWindow(currentWindow);	}		// The floating windows are now hidden.  Deactivate the first visible	// document window.	currentWindow = MyFrontNonFloatingWindow();	if (currentWindow != nil)		MyDeactivateWindow(currentWindow);}//// ResumeFloatingWindows////	Reveal floating windows that were hidden by SuspendFloatingWindows.  An//	activate event is sent to each one as it is revealed.  The frontmost document//	is also sent an activate event.//pascal void ResumeFloatingWindows(void){	WindowRef	currentWindow;	Boolean		windowWasVisible;		#if TARGET_API_MAC_CARBON	currentWindow = GetWindowList();	#else	currentWindow = LMGetWindowList();	#endif		// used to return here if there are no floaters, but that meant that 	// the front doc window didn't get activated if there were no floaters.	// Now we return only if the first visible window is modal, because the floaters	// and doc window should stay deactivated.	if(WindowIsModal(FrontWindow()))		return;			while ((currentWindow != nil) && (GetWindowKind(currentWindow) == kApplicationFloaterKind))	{		windowWasVisible = GetWasVisible(currentWindow);		if (windowWasVisible) {			ShowHide( currentWindow, true);			MyActivateWindow(currentWindow);		}		currentWindow = GetNextWindow(currentWindow);	}	// The floating windows have been revealed.  Activate the first document	// window as well.	currentWindow = MyFrontNonFloatingWindow();	if (currentWindow != nil)		MyActivateWindow(currentWindow);}#endif//// MyActivateWindow////	Activates the window by highlighting it, and calling its activate handler.//void MyActivateWindow(WindowRef theWindow){	HighlightAndActivateWindow(theWindow, kActivateWindow);}//// MyDeactivateWindow////	Deactivates the window by unhighlighting it and calling its activate handler.//void MyDeactivateWindow(WindowRef theWindow){	HighlightAndActivateWindow(theWindow, kDeactivateWindow);}//// HighlightAndActivateWindow////	Common code for MyActivateWindow and MyDeactivateWindow.  Does actual highlighting//	and calling of the activate handler.//void HighlightAndActivateWindow(WindowRef theWindow, Boolean activate){	ActivateHandlerUPP	activateHandlerProc;		if(theWindow == nil)		return;	activateHandlerProc = GetActivateHandlerProc(theWindow);	HiliteWindow( theWindow, activate);	if (activateHandlerProc != nil)		CallActivateHandlerProc(activateHandlerProc, theWindow, activate);}//// ValidateWindowList////	Code external to the application might call SelectWindow because they//	don’t know any better. If the application has floating windows that are invisible//	when some other code calls FrontWindow then SelectWindow, a document window will get//	pulled in front of the invisible floating windows. This routine makes sure everything//	is right with the world, or at least the window list. It assumes that the floating//	windows are invisible, so visually, nothing changes on the screen. This means that//	the code doesn’t call CalcVBehind or PaintBehind. If I wanted to be more general,//	those two calls would have to be made. Ideally, this routine only needs to be called//	the first time window ordering changes after a foreign window was opened in your//	application. I’m actually calling it every time ShowReferencedWindow is called on//	a floating window, and when new document windows are created or closed, just to be//	safe.//// dkj - Rewritten not to muck directly with the window list. The strategy is to use BringToFront// to pull floaters forward (it doesn't change highlighting or generate activate events), but// only if necessary.pascal void ValidateWindowList(void){	#if TARGET_API_MAC_CARBON	WindowRef	thisWindow = GetWindowList();	#else	WindowRef	thisWindow = LMGetWindowList();	#endif	WindowRef	lastFloatingWindow = LastFloatingWindow();		// If there are no floaters, do nothing	if(lastFloatingWindow == nil)		return;		// if the first window is a floater, assume we're OK (this assumes a doc window will	// never get "between" floaters in the window list, but so did the old routine).	if(GetWindowKind(thisWindow) == kApplicationFloaterKind)		return;		// if the first window is modal, don't do anything: this routine should never really be 	// called while a modal dialog is up, but you never know...	if(WindowIsModal(thisWindow))		return;		// Damn, floaters exist but there's a non-floater, non-modal in front.	It'd be easiest to use	// SendBehind to send it behind the floaters, but that might generate activate events	// (a Bad Thing) so I'll laboriously call BringToFront for each floater, in reverse order.	// This is a recursive routine, that calls BringToFront during the unwind.	BringFloatersToFront(thisWindow);}//// Getters and Setters//// Get/SetActivateHandlerProc — get and set the activate event handler for this windowpascal ActivateHandlerUPP GetActivateHandlerProc(WindowRef windowReference){	WindowRefExtensions		**extH;		extH = (WindowRefExtensions **)GetWRefCon(windowReference);	if(extH != nil)		return ((*extH)->activateHandlerProc);	else		return nil;}pascal void SetActivateHandlerProc(WindowRef windowReference, ActivateHandlerUPP activateHandlerProc){	WindowRefExtensions		**extH;		extH = (WindowRefExtensions **)GetWRefCon(windowReference);	if(extH != nil)	{		(*extH)->activateHandlerProc = activateHandlerProc;		SetWRefCon(windowReference, (long)extH);	}}pascal long GetExtWRefCon(WindowRef windowReference){	WindowRefExtensions		**extH;		extH = (WindowRefExtensions **)GetWRefCon(windowReference);	if(extH != nil)		return ((*extH)->userRefCon);	else		return 0;}pascal void SetExtWRefCon(WindowRef windowReference, long refCon){	WindowRefExtensions		**extH;		extH = (WindowRefExtensions **)GetWRefCon(windowReference);	if(extH != nil)	{		(*extH)->userRefCon = refCon;	}}// Return the next visible windowpascal WindowRef GetNextVisibleWindow(WindowRef window){	WindowRef	thisWindow;		thisWindow = GetNextWindow(window);	while(thisWindow != nil)	{		if(IsWindowVisible(thisWindow))			break;		thisWindow = GetNextWindow(thisWindow);	}	return thisWindow;}#if !TARGET_API_MAC_CARBON// private getter/setterBoolean GetWasVisible(WindowRef windowReference){	WindowRefExtensions		**extH;		extH = (WindowRefExtensions **)GetWRefCon(windowReference);	if(extH != nil)		return ((*extH)->wasVisible);	else		return false;}#endifvoid SetWasVisible(WindowRef windowReference, Boolean wasVisible){	WindowRefExtensions		**extH;		extH = (WindowRefExtensions **)GetWRefCon(windowReference);	if(extH != nil)	{		(*extH)->wasVisible = wasVisible;		SetWRefCon(windowReference, (long)extH);	}}// Convert a set of window attributes to the appropriate procIDOSErr AttributesToWindowInfo(MyWindowAttributes attributes,				short *procID, Boolean *hasGoAway, MyWindowAttributes *titleBarType){	OSErr				result = noErr;	Boolean				isFloater = false;	// Determine the type of title bar this window has, if any.	*titleBarType = attributes & kWindowTitlebarMask;	if (*titleBarType != 0) {		switch (*titleBarType) {			#if !TARGET_API_MAC_CARBON			case kHasRoundedTitlebarMask:				*procID = rDocProc;				break;			#endif						case kHasDocumentTitlebarMask:				*procID = documentProc;				break;							case kHasPaletteTitlebarMask:				*procID = kMyFloaterProc;				isFloater = true;				break;							default:				*procID = documentProc;				result = kUndefinedTitleBarTypeError;				break;		}				// This window has a title bar. See what kind of gadgets it has in it.		if (attributes & kHasModalBorderMask) // Moveable modals don’t get zoom, close, or grow boxes			*procID += kMovableModalDialogVariantCode;		else {			if (attributes & kHasCloseBoxMask)				*hasGoAway = true;			if (*titleBarType != kHasRoundedTitlebarMask) // rounded windows don't get any other goodies			{				if (attributes & kHasZoomBoxMask)					// variant codes for floaters are different than those for document windows					*procID += (isFloater ? kFloaterZoomVariantCode : zoomDocProc);				if(!(attributes & kHasGrowBoxMask))					// only change if not a floater (normally has a grow box)					*procID += (isFloater ? 0 : noGrowDocProc);				else					// only change if this is a floater (normally doesn't have a grow box)					*procID += (isFloater ? kFloaterGrowVariantCode : 0);				// floaters can have "sidebars"				if (isFloater && (attributes & kHasSideTitleBarMask))					*procID += kSideFloaterVariantCode;			}		}	}		// This window has no title bar, so it’s a modal dialog of some sort.	else {		*procID = dBoxProc;								// Start with the standard dialog type		if (!(attributes & kHasModalBorderMask)) {			*procID = plainDBox;							// This isn’t the standard modal type			if (attributes & kHasThickDropShadowMask)	// These types can have a deeper drop shadow				*procID = altDBoxProc;		}	}	return result;}OSErr CheckWindowOrdering(Boolean isModal, Boolean isFloater, WindowRef *behind){	OSErr		result = noErr;	WindowRef	lastFloater;	 	if(isFloater) // it's a floater 	{ 		/*  Illegal cases for floater creation: 			1 - behind is nil (meaning make the window behind all others) but 				there are non-floaters around 			2 - behind is a non-floating window  		 */ 		if (((*behind == nil) && (MyFrontNonFloatingWindow() != nil)) ||			((*behind != (WindowRef) -1) && (GetWindowKind(*behind) != kApplicationFloaterKind))	)		{			result = kInvalidWindowOrderingError;		} 	} 	else if(isModal) // it's a modal dialog 	{ 		// be dictatorial and make sure that behind is -1, meaning put it in front of all others 		if(*behind != (WindowRef) -1) 			result = kInvalidWindowOrderingError; 	} 	else 	// Regular window, not a floater or modal; make sure it's behind all floaters 	{ 		// see if there are already floaters up 		lastFloater = LastFloatingWindow(); 		if(lastFloater != nil) 		{ 			// if they want it in front, put it behind all floaters			if(*behind == (WindowRef) -1)				*behind = lastFloater;			// if they want it behind a window that is a floater but not the last floater,			// it's an error			else if(*behind != nil && *behind != lastFloater &&						(GetWindowKind(*behind) == kApplicationFloaterKind))			{				result = kInvalidWindowOrderingError;			}		} 	} 	return result;}// Decides what kind of window a particular WIND resource specifies. This routine assumes the// structure of the WIND resource and assumes that the upper 12 bits of the definitionID// contain the resource ID of the WDEF.OSErr	GetWINDStats(short windID, Boolean *isModal, Boolean *isFloater, Boolean *isVisible){	Handle			windHandle;	unsigned short	procID;	OSErr			result = resNotFound;		windHandle = Get1Resource('WIND', windID);	if(windHandle != nil)	{		// Get the  proc ID, a short, 8 bytes into the block		HLock(windHandle);		procID = *((unsigned short *)(((char *)(*windHandle)) + 8));				// see if it's a modal window		if(	procID == dBoxProc		||			procID == plainDBox		||			procID == altDBoxProc	||			procID == movableDBoxProc	)		{			*isModal = true;			*isFloater = false; // can't be a floater if it's modal		}		else // not modal, is it a floater?		{			*isModal = false;						// shift right 4 bits to get resource id			procID >>= 4;			if(procID == kMyFloaterResID || procID == kFloatingWindowDefinition ||				procID == kWindowUtilityDefProcResID || procID == kWindowUtilitySideTitleDefProcResID)				*isFloater = true;			else				*isFloater = false;		}				// Get the visibility status, a short, 10 bytes into the block		*isVisible = (Boolean)*((unsigned short *)(((char *)(*windHandle)) + 10));				// Done with WIND, signal success		HUnlock(windHandle);		ReleaseResource(windHandle);		result = noErr;	}	return result;}Boolean	IsFrontProcess(void){	ProcessSerialNumber	currentPSN;	ProcessSerialNumber	frontPSN;	OSErr				getFrontProcessResult;	OSErr				getCurrentProcessResult;	Boolean				isSameProcess = false;		// Compare this process and the front process	getFrontProcessResult = GetFrontProcess(&frontPSN);	getCurrentProcessResult = GetCurrentProcess(&currentPSN);		if ((getFrontProcessResult == noErr) && (getCurrentProcessResult == noErr))		SameProcess(&frontPSN, &currentPSN, &isSameProcess);			return isSameProcess;}// A recursive routine that brings all floaters to the front of the window list. When// one is found, it remembers it and then calls itself to look further. When we get to // the end of the window list, we unwind, calling BringToFront on each floater on each// floater, so the order when finished is unchanged. void BringFloatersToFront(WindowRef thisWindow){	WindowRef	thisFloater;		// Find the next floater	while(thisWindow != nil && GetWindowKind(thisWindow) != kApplicationFloaterKind)		thisWindow = GetNextWindow(thisWindow);		if(thisWindow == nil)		return;	// remember this floater	thisFloater = thisWindow;		// look for more	BringFloatersToFront(GetNextWindow(thisWindow));		// call BringToFront on the way out	BringToFront(thisFloater);}